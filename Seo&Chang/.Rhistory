rm(list = ls())
set.seed(1155)
user <- Sys.getenv("RSTUDIO_USER_IDENTITY")
paste('/Users/', user, '/Dropbox/Seo&Chang/PPois_with_SetControl.R', sep = '') %>%
source
b1 <- rep(1, 3)
q <- c(5e1, 3e1) - 3
n <- c(1e2, 2e2, 4e2, 8e2)/4
models <- list()
for (ni in 1:length(n)) {
for (qi in 1:length(q)) {
eval(paste('n', n[ni], 'q', q[qi], sep = '') %>%
paste('models$', ., ' <- list(n = n[', ni, '], b.vec = c(b1, rep(0, q[', qi,
'])))', sep = '') %>% parse(text = .))
}
}
K <- 1
cvf <- 5
imax <- 2e2
eps0 <- 1e-6
timer <- c()
modeliter <- 1
profvis({for (modeliter in 1:length(models)) {
k <- 1
n <- models[[modeliter]]$n
p <- length(models[[modeliter]]$b.vec)
b.vec <- models[[modeliter]]$b.vec
models[[modeliter]]$unres.MSE <- rep(NA, K)
models[[modeliter]]$lasso.MSE <- rep(NA, K)
# models[[modeliter]]$scad.MSE <- rep(NA, K)
models[[modeliter]]$mcl.MSE <- rep(NA, K)
r <- 10
while (k <= K) {
tic(paste(names(models)[modeliter], '~' , round(k/K*1e2, 1), '%',
'(Est. rem. tm.', '=', round((K - k)*median(timer)/60, 1), 'ms)'))
x.mat0 = rmvn(n, rep(0, p), sigma = diag(1/r, p))
exb.vec = exp(drop(x.mat0 %*% b.vec)) ; m.vec = exb.vec
y.vec0 = rpois(n, m.vec)
lam.max <- max(abs(grad.fun(y.vec0, x.mat0, rep(0, p))))
lam.min <- lam.max*1e-3
lamv <- exp(seq(log(lam.max), log(lam.min), length.out = 50))
# lasso.fit <- lasso.path.fun(y.vec0, x.mat0, lamv, imax, eps0)
x.mat1 = rmvn(n/2, rep(0, p), sigma = diag(1/r, p))
exb.vec = exp(drop(x.mat0 %*% b.vec)) ; m.vec = exb.vec
y.vec1 = rpois(n/2, m.vec)
fold.id <- split(sample(1:n), 1:cvf) ; fid <- 1:n
lasso.cverr <- c()
for (fold in 1:cvf) {
x.mat <- x.mat0[fold.id[[fold]],]
y.vec <- y.vec0[fold.id[[fold]]]
y.mat <- matrix(rep(y.vec, length(lamv)), nrow = length(y.vec), byrow = F)
lasso.fit <- lasso.path.fun(y.vec, x.mat, lamv, imax, eps0)
haty.mat <- exp(x.mat %*% lasso.fit$b.mat)
lasso.cverr <- rbind(lasso.cverr, colSums((y.mat - haty.mat)^2))
}
lasso.cverr <- colMeans(lasso.cverr)
hatgam <- hatlam <- lamv[which.min(lasso.cverr)]
lasso.fit <- lasso.path.fun(y.vec0, x.mat0, hatlam, imax, eps0)
haty.vec <- exp(x.mat1 %*% lasso.fit$b.mat)
models[[modeliter]]$lasso.MSE[k] <- mean((y.vec1 - haty.vec)^2)
mcl.cverr <- c()
mclamv <- lamv[lamv >= hatlam]
for (fold in 1:cvf) {
x.mat <- x.mat0[fold.id[[fold]],]
y.vec <- y.vec0[fold.id[[fold]]]
y.mat <- matrix(rep(y.vec, length(mclamv)), nrow = length(y.vec), byrow = F)
mcl.fit <- mcl.path.fun(y.vec, x.mat, 2.1, hatgam, mclamv, imax, eps0)
haty.mat <- exp(x.mat %*% mcl.fit$b.mat)
mcl.cverr <- rbind(mcl.cverr, colSums((y.mat - haty.mat)^2))
}
mcl.cverr <- colMeans(mcl.cverr)
hatlam <- mclamv[which.min(mcl.cverr)]
mcl.fit <- mcl.path.fun(y.vec0, x.mat0, 2.1, hatgam, hatlam, imax, eps0)
haty.vec <- exp(x.mat1 %*% mcl.fit$b.mat)
models[[modeliter]]$mcl.MSE[k] <- mean((y.vec1 - haty.vec)^2)
if (n >= p) {
df0 <- data.frame(y.vec0, x.mat0)
df1 <- data.frame(y.vec1, x.mat1)
unres.fit <- glm(y.vec0 ~ . - 1, data = df0, family = 'poisson')
haty.vec <- predict(unres.fit, df1[,-1])
models[[modeliter]]$unres.MSE[k] <- mean((y.vec1 - haty.vec)^2)
}
tsq <- toc()
timer <- c(timer, tsq$toc - tsq$tic)
k <- k + 1
print(hatgam) ; print(hatlam)
boxplot(models[[modeliter]][-(1:2)], main = names(models)[modeliter])
}
save(models, file = paste('/Users/', user, '/Dropbox/Seo&Chang/Simulations.RData', sep = ''))
}})
?profvis
profvis({
dat <- data.frame(
x = rnorm(5e4),
y = rnorm(5e4)
)
plot(x ~ y, data = dat)
m <- lm(x ~ y, data = dat)
abline(m, col = "red")
})
profvis({
dat <- data.frame(
x = rnorm(5e4),
y = rnorm(5e4)
)
plot(x ~ y, data = dat)
m <- lm(x ~ y, data = dat)
abline(m, col = "red")
})
lib <- c('mvnfast', 'dplyr', 'tictoc', 'glmnet', 'profvis')
chck <- sapply(lib, require, character.only = TRUE)
if (sum(!chck) > 0) {install.packages(lib[!chck])}
rm(list = ls())
set.seed(1155)
user <- Sys.getenv("RSTUDIO_USER_IDENTITY")
paste('/Users/', user, '/Dropbox/Seo&Chang/PPois_with_SetControl.R', sep = '') %>%
source
b1 <- rep(1, 3)
q <- c(5e1, 3e1) - 3
n <- c(1e2, 2e2, 4e2, 8e2)/4
models <- list()
for (ni in 1:length(n)) {
for (qi in 1:length(q)) {
eval(paste('n', n[ni], 'q', q[qi], sep = '') %>%
paste('models$', ., ' <- list(n = n[', ni, '], b.vec = c(b1, rep(0, q[', qi,
'])))', sep = '') %>% parse(text = .))
}
}
K <- 1
cvf <- 5
imax <- 2e2
eps0 <- 1e-6
timer <- c()
modeliter <- 1
profvis({for (modeliter in 1:length(models)) {
k <- 1
n <- models[[modeliter]]$n
p <- length(models[[modeliter]]$b.vec)
b.vec <- models[[modeliter]]$b.vec
models[[modeliter]]$unres.MSE <- rep(NA, K)
models[[modeliter]]$lasso.MSE <- rep(NA, K)
# models[[modeliter]]$scad.MSE <- rep(NA, K)
models[[modeliter]]$mcl.MSE <- rep(NA, K)
r <- 10
while (k <= K) {
tic(paste(names(models)[modeliter], '~' , round(k/K*1e2, 1), '%',
'(Est. rem. tm.', '=', round((K - k)*median(timer)/60, 1), 'ms)'))
x.mat0 = rmvn(n, rep(0, p), sigma = diag(1/r, p))
exb.vec = exp(drop(x.mat0 %*% b.vec)) ; m.vec = exb.vec
y.vec0 = rpois(n, m.vec)
lam.max <- max(abs(grad.fun(y.vec0, x.mat0, rep(0, p))))
lam.min <- lam.max*1e-3
lamv <- exp(seq(log(lam.max), log(lam.min), length.out = 50))
# lasso.fit <- lasso.path.fun(y.vec0, x.mat0, lamv, imax, eps0)
x.mat1 = rmvn(n/2, rep(0, p), sigma = diag(1/r, p))
exb.vec = exp(drop(x.mat0 %*% b.vec)) ; m.vec = exb.vec
y.vec1 = rpois(n/2, m.vec)
fold.id <- split(sample(1:n), 1:cvf) ; fid <- 1:n
lasso.cverr <- c()
for (fold in 1:cvf) {
x.mat <- x.mat0[fold.id[[fold]],]
y.vec <- y.vec0[fold.id[[fold]]]
y.mat <- matrix(rep(y.vec, length(lamv)), nrow = length(y.vec), byrow = F)
lasso.fit <- lasso.path.fun(y.vec, x.mat, lamv, imax, eps0)
haty.mat <- exp(x.mat %*% lasso.fit$b.mat)
lasso.cverr <- rbind(lasso.cverr, colSums((y.mat - haty.mat)^2))
}
lasso.cverr <- colMeans(lasso.cverr)
hatgam <- hatlam <- lamv[which.min(lasso.cverr)]
lasso.fit <- lasso.path.fun(y.vec0, x.mat0, hatlam, imax, eps0)
haty.vec <- exp(x.mat1 %*% lasso.fit$b.mat)
models[[modeliter]]$lasso.MSE[k] <- mean((y.vec1 - haty.vec)^2)
mcl.cverr <- c()
mclamv <- lamv[lamv >= hatlam]
for (fold in 1:cvf) {
x.mat <- x.mat0[fold.id[[fold]],]
y.vec <- y.vec0[fold.id[[fold]]]
y.mat <- matrix(rep(y.vec, length(mclamv)), nrow = length(y.vec), byrow = F)
mcl.fit <- mcl.path.fun(y.vec, x.mat, 2.1, hatgam, mclamv, imax, eps0)
haty.mat <- exp(x.mat %*% mcl.fit$b.mat)
mcl.cverr <- rbind(mcl.cverr, colSums((y.mat - haty.mat)^2))
}
mcl.cverr <- colMeans(mcl.cverr)
hatlam <- mclamv[which.min(mcl.cverr)]
mcl.fit <- mcl.path.fun(y.vec0, x.mat0, 2.1, hatgam, hatlam, imax, eps0)
haty.vec <- exp(x.mat1 %*% mcl.fit$b.mat)
models[[modeliter]]$mcl.MSE[k] <- mean((y.vec1 - haty.vec)^2)
if (n >= p) {
df0 <- data.frame(y.vec0, x.mat0)
df1 <- data.frame(y.vec1, x.mat1)
unres.fit <- glm(y.vec0 ~ . - 1, data = df0, family = 'poisson')
haty.vec <- predict(unres.fit, df1[,-1])
models[[modeliter]]$unres.MSE[k] <- mean((y.vec1 - haty.vec)^2)
}
tsq <- toc()
timer <- c(timer, tsq$toc - tsq$tic)
k <- k + 1
print(hatgam) ; print(hatlam)
boxplot(models[[modeliter]][-(1:2)], main = names(models)[modeliter])
}
save(models, file = paste('/Users/', user, '/Dropbox/Seo&Chang/Simulations.RData', sep = ''))
}})
lib <- c('mvnfast', 'dplyr', 'tictoc', 'glmnet', 'profvis')
chck <- sapply(lib, require, character.only = TRUE)
if (sum(!chck) > 0) {install.packages(lib[!chck])}
rm(list = ls())
set.seed(1155)
user <- Sys.getenv("RSTUDIO_USER_IDENTITY")
paste('/Users/', user, '/Dropbox/Seo&Chang/PPois_with_SetControl.R', sep = '') %>%
source
b1 <- rep(1, 3)
q <- c(5e1, 3e1) - 3
n <- c(1e2, 2e2, 4e2, 8e2)/4
models <- list()
for (ni in 1:length(n)) {
for (qi in 1:length(q)) {
eval(paste('n', n[ni], 'q', q[qi], sep = '') %>%
paste('models$', ., ' <- list(n = n[', ni, '], b.vec = c(b1, rep(0, q[', qi,
'])))', sep = '') %>% parse(text = .))
}
}
K <- 1
cvf <- 5
imax <- 2e2
eps0 <- 1e-6
timer <- c()
modeliter <- 1
profvis({for (modeliter in 1:length(models)) {
k <- 1
n <- models[[modeliter]]$n
p <- length(models[[modeliter]]$b.vec)
b.vec <- models[[modeliter]]$b.vec
models[[modeliter]]$unres.MSE <- rep(NA, K)
models[[modeliter]]$lasso.MSE <- rep(NA, K)
# models[[modeliter]]$scad.MSE <- rep(NA, K)
models[[modeliter]]$mcl.MSE <- rep(NA, K)
r <- 10
while (k <= K) {
tic(paste(names(models)[modeliter], '~' , round(k/K*1e2, 1), '%',
'(Est. rem. tm.', '=', round((K - k)*median(timer)/60, 1), 'ms)'))
x.mat0 = rmvn(n, rep(0, p), sigma = diag(1/r, p))
exb.vec = exp(drop(x.mat0 %*% b.vec)) ; m.vec = exb.vec
y.vec0 = rpois(n, m.vec)
lam.max <- max(abs(grad.fun(y.vec0, x.mat0, rep(0, p))))
lam.min <- lam.max*1e-3
lamv <- exp(seq(log(lam.max), log(lam.min), length.out = 50))
# lasso.fit <- lasso.path.fun(y.vec0, x.mat0, lamv, imax, eps0)
x.mat1 = rmvn(n/2, rep(0, p), sigma = diag(1/r, p))
exb.vec = exp(drop(x.mat0 %*% b.vec)) ; m.vec = exb.vec
y.vec1 = rpois(n/2, m.vec)
fold.id <- split(sample(1:n), 1:cvf) ; fid <- 1:n
lasso.cverr <- c()
for (fold in 1:cvf) {
x.mat <- x.mat0[fold.id[[fold]],]
y.vec <- y.vec0[fold.id[[fold]]]
y.mat <- matrix(rep(y.vec, length(lamv)), nrow = length(y.vec), byrow = F)
lasso.fit <- lasso.path.fun(y.vec, x.mat, lamv, imax, eps0)
haty.mat <- exp(x.mat %*% lasso.fit$b.mat)
lasso.cverr <- rbind(lasso.cverr, colSums((y.mat - haty.mat)^2))
}
lasso.cverr <- colMeans(lasso.cverr)
hatgam <- hatlam <- lamv[which.min(lasso.cverr)]
lasso.fit <- lasso.path.fun(y.vec0, x.mat0, hatlam, imax, eps0)
haty.vec <- exp(x.mat1 %*% lasso.fit$b.mat)
models[[modeliter]]$lasso.MSE[k] <- mean((y.vec1 - haty.vec)^2)
mcl.cverr <- c()
mclamv <- lamv[lamv >= hatlam]
for (fold in 1:cvf) {
x.mat <- x.mat0[fold.id[[fold]],]
y.vec <- y.vec0[fold.id[[fold]]]
y.mat <- matrix(rep(y.vec, length(mclamv)), nrow = length(y.vec), byrow = F)
mcl.fit <- mcl.path.fun(y.vec, x.mat, 2.1, hatgam, mclamv, imax, eps0)
haty.mat <- exp(x.mat %*% mcl.fit$b.mat)
mcl.cverr <- rbind(mcl.cverr, colSums((y.mat - haty.mat)^2))
}
mcl.cverr <- colMeans(mcl.cverr)
hatlam <- mclamv[which.min(mcl.cverr)]
mcl.fit <- mcl.path.fun(y.vec0, x.mat0, 2.1, hatgam, hatlam, imax, eps0)
haty.vec <- exp(x.mat1 %*% mcl.fit$b.mat)
models[[modeliter]]$mcl.MSE[k] <- mean((y.vec1 - haty.vec)^2)
if (n >= p) {
df0 <- data.frame(y.vec0, x.mat0)
df1 <- data.frame(y.vec1, x.mat1)
unres.fit <- glm(y.vec0 ~ . - 1, data = df0, family = 'poisson')
haty.vec <- predict(unres.fit, df1[,-1])
models[[modeliter]]$unres.MSE[k] <- mean((y.vec1 - haty.vec)^2)
}
tsq <- toc()
timer <- c(timer, tsq$toc - tsq$tic)
k <- k + 1
print(hatgam) ; print(hatlam)
boxplot(models[[modeliter]][-(1:2)], main = names(models)[modeliter])
}
save(models, file = paste('/Users/', user, '/Dropbox/Seo&Chang/Simulations.RData', sep = ''))
}})
lib <- c('mvnfast', 'dplyr', 'tictoc', 'glmnet', 'profvis')
chck <- sapply(lib, require, character.only = TRUE)
if (sum(!chck) > 0) {install.packages(lib[!chck])}
rm(list = ls())
set.seed(1155)
user <- Sys.getenv("RSTUDIO_USER_IDENTITY")
paste('/Users/', user, '/Dropbox/Seo&Chang/PPois_with_SetControl.R', sep = '') %>%
source
b1 <- rep(1, 3)
q <- c(5e1, 3e1) - 3
n <- c(1e2, 2e2, 4e2, 8e2)/4
models <- list()
for (ni in 1:length(n)) {
for (qi in 1:length(q)) {
eval(paste('n', n[ni], 'q', q[qi], sep = '') %>%
paste('models$', ., ' <- list(n = n[', ni, '], b.vec = c(b1, rep(0, q[', qi,
'])))', sep = '') %>% parse(text = .))
}
}
K <- 1
cvf <- 5
imax <- 2e2
eps0 <- 1e-6
timer <- c()
modeliter <- 1
profvis({for (modeliter in 1:length(models)) {
k <- 1
n <- models[[modeliter]]$n
p <- length(models[[modeliter]]$b.vec)
b.vec <- models[[modeliter]]$b.vec
models[[modeliter]]$unres.MSE <- rep(NA, K)
models[[modeliter]]$lasso.MSE <- rep(NA, K)
# models[[modeliter]]$scad.MSE <- rep(NA, K)
models[[modeliter]]$mcl.MSE <- rep(NA, K)
r <- 10
while (k <= K) {
tic(paste(names(models)[modeliter], '~' , round(k/K*1e2, 1), '%',
'(Est. rem. tm.', '=', round((K - k)*median(timer)/60, 1), 'ms)'))
x.mat0 = rmvn(n, rep(0, p), sigma = diag(1/r, p))
exb.vec = exp(drop(x.mat0 %*% b.vec)) ; m.vec = exb.vec
y.vec0 = rpois(n, m.vec)
lam.max <- max(abs(grad.fun(y.vec0, x.mat0, rep(0, p))))
lam.min <- lam.max*1e-3
lamv <- exp(seq(log(lam.max), log(lam.min), length.out = 50))
# lasso.fit <- lasso.path.fun(y.vec0, x.mat0, lamv, imax, eps0)
x.mat1 = rmvn(n/2, rep(0, p), sigma = diag(1/r, p))
exb.vec = exp(drop(x.mat0 %*% b.vec)) ; m.vec = exb.vec
y.vec1 = rpois(n/2, m.vec)
fold.id <- split(sample(1:n), 1:cvf) ; fid <- 1:n
lasso.cverr <- c()
for (fold in 1:cvf) {
x.mat <- x.mat0[fold.id[[fold]],]
y.vec <- y.vec0[fold.id[[fold]]]
y.mat <- matrix(rep(y.vec, length(lamv)), nrow = length(y.vec), byrow = F)
lasso.fit <- lasso.path.fun(y.vec, x.mat, lamv, imax, eps0)
haty.mat <- exp(x.mat %*% lasso.fit$b.mat)
lasso.cverr <- rbind(lasso.cverr, colSums((y.mat - haty.mat)^2))
}
lasso.cverr <- colMeans(lasso.cverr)
hatgam <- hatlam <- lamv[which.min(lasso.cverr)]
lasso.fit <- lasso.path.fun(y.vec0, x.mat0, hatlam, imax, eps0)
haty.vec <- exp(x.mat1 %*% lasso.fit$b.mat)
models[[modeliter]]$lasso.MSE[k] <- mean((y.vec1 - haty.vec)^2)
mcl.cverr <- c()
mclamv <- lamv[lamv >= hatlam]
for (fold in 1:cvf) {
x.mat <- x.mat0[fold.id[[fold]],]
y.vec <- y.vec0[fold.id[[fold]]]
y.mat <- matrix(rep(y.vec, length(mclamv)), nrow = length(y.vec), byrow = F)
mcl.fit <- mcl.path.fun(y.vec, x.mat, 2.1, hatgam, mclamv, imax, eps0)
haty.mat <- exp(x.mat %*% mcl.fit$b.mat)
mcl.cverr <- rbind(mcl.cverr, colSums((y.mat - haty.mat)^2))
}
mcl.cverr <- colMeans(mcl.cverr)
hatlam <- mclamv[which.min(mcl.cverr)]
mcl.fit <- mcl.path.fun(y.vec0, x.mat0, 2.1, hatgam, hatlam, imax, eps0)
haty.vec <- exp(x.mat1 %*% mcl.fit$b.mat)
models[[modeliter]]$mcl.MSE[k] <- mean((y.vec1 - haty.vec)^2)
if (n >= p) {
df0 <- data.frame(y.vec0, x.mat0)
df1 <- data.frame(y.vec1, x.mat1)
unres.fit <- glm(y.vec0 ~ . - 1, data = df0, family = 'poisson')
haty.vec <- predict(unres.fit, df1[,-1])
models[[modeliter]]$unres.MSE[k] <- mean((y.vec1 - haty.vec)^2)
}
tsq <- toc()
timer <- c(timer, tsq$toc - tsq$tic)
k <- k + 1
print(hatgam) ; print(hatlam)
boxplot(models[[modeliter]][-(1:2)], main = names(models)[modeliter])
}
save(models, file = paste('/Users/', user, '/Dropbox/Seo&Chang/Simulations.RData', sep = ''))
}})
lib <- c('mvnfast', 'dplyr', 'tictoc', 'glmnet', 'profvis')
chck <- sapply(lib, require, character.only = TRUE)
if (sum(!chck) > 0) {install.packages(lib[!chck])}
rm(list = ls())
set.seed(1155)
user <- Sys.getenv("RSTUDIO_USER_IDENTITY")
paste('/Users/', user, '/Dropbox/Seo&Chang/PPois_with_SetControl.R', sep = '') %>%
source
b1 <- rep(1, 3)
q <- c(5e1, 3e1) - 3
n <- c(1e2, 2e2, 4e2, 8e2)/4
models <- list()
for (ni in 1:length(n)) {
for (qi in 1:length(q)) {
eval(paste('n', n[ni], 'q', q[qi], sep = '') %>%
paste('models$', ., ' <- list(n = n[', ni, '], b.vec = c(b1, rep(0, q[', qi,
'])))', sep = '') %>% parse(text = .))
}
}
K <- 1
cvf <- 5
imax <- 2e2
eps0 <- 1e-6
timer <- c()
modeliter <- 1
# profvis({for (modeliter in 1:length(models)) {
profvis({for (modeliter in 1:1) {
k <- 1
n <- models[[modeliter]]$n
p <- length(models[[modeliter]]$b.vec)
b.vec <- models[[modeliter]]$b.vec
models[[modeliter]]$unres.MSE <- rep(NA, K)
models[[modeliter]]$lasso.MSE <- rep(NA, K)
# models[[modeliter]]$scad.MSE <- rep(NA, K)
models[[modeliter]]$mcl.MSE <- rep(NA, K)
r <- 10
while (k <= K) {
tic(paste(names(models)[modeliter], '~' , round(k/K*1e2, 1), '%',
'(Est. rem. tm.', '=', round((K - k)*median(timer)/60, 1), 'ms)'))
x.mat0 = rmvn(n, rep(0, p), sigma = diag(1/r, p))
exb.vec = exp(drop(x.mat0 %*% b.vec)) ; m.vec = exb.vec
y.vec0 = rpois(n, m.vec)
lam.max <- max(abs(grad.fun(y.vec0, x.mat0, rep(0, p))))
lam.min <- lam.max*1e-3
lamv <- exp(seq(log(lam.max), log(lam.min), length.out = 50))
# lasso.fit <- lasso.path.fun(y.vec0, x.mat0, lamv, imax, eps0)
x.mat1 = rmvn(n/2, rep(0, p), sigma = diag(1/r, p))
exb.vec = exp(drop(x.mat0 %*% b.vec)) ; m.vec = exb.vec
y.vec1 = rpois(n/2, m.vec)
fold.id <- split(sample(1:n), 1:cvf) ; fid <- 1:n
lasso.cverr <- c()
for (fold in 1:cvf) {
x.mat <- x.mat0[fold.id[[fold]],]
y.vec <- y.vec0[fold.id[[fold]]]
y.mat <- matrix(rep(y.vec, length(lamv)), nrow = length(y.vec), byrow = F)
lasso.fit <- lasso.path.fun(y.vec, x.mat, lamv, imax, eps0)
haty.mat <- exp(x.mat %*% lasso.fit$b.mat)
lasso.cverr <- rbind(lasso.cverr, colSums((y.mat - haty.mat)^2))
}
lasso.cverr <- colMeans(lasso.cverr)
hatgam <- hatlam <- lamv[which.min(lasso.cverr)]
lasso.fit <- lasso.path.fun(y.vec0, x.mat0, hatlam, imax, eps0)
haty.vec <- exp(x.mat1 %*% lasso.fit$b.mat)
models[[modeliter]]$lasso.MSE[k] <- mean((y.vec1 - haty.vec)^2)
mcl.cverr <- c()
mclamv <- lamv[lamv >= hatlam]
for (fold in 1:cvf) {
x.mat <- x.mat0[fold.id[[fold]],]
y.vec <- y.vec0[fold.id[[fold]]]
y.mat <- matrix(rep(y.vec, length(mclamv)), nrow = length(y.vec), byrow = F)
mcl.fit <- mcl.path.fun(y.vec, x.mat, 2.1, hatgam, mclamv, imax, eps0)
haty.mat <- exp(x.mat %*% mcl.fit$b.mat)
mcl.cverr <- rbind(mcl.cverr, colSums((y.mat - haty.mat)^2))
}
mcl.cverr <- colMeans(mcl.cverr)
hatlam <- mclamv[which.min(mcl.cverr)]
mcl.fit <- mcl.path.fun(y.vec0, x.mat0, 2.1, hatgam, hatlam, imax, eps0)
haty.vec <- exp(x.mat1 %*% mcl.fit$b.mat)
models[[modeliter]]$mcl.MSE[k] <- mean((y.vec1 - haty.vec)^2)
if (n >= p) {
df0 <- data.frame(y.vec0, x.mat0)
df1 <- data.frame(y.vec1, x.mat1)
unres.fit <- glm(y.vec0 ~ . - 1, data = df0, family = 'poisson')
haty.vec <- predict(unres.fit, df1[,-1])
models[[modeliter]]$unres.MSE[k] <- mean((y.vec1 - haty.vec)^2)
}
tsq <- toc()
timer <- c(timer, tsq$toc - tsq$tic)
k <- k + 1
print(hatgam) ; print(hatlam)
boxplot(models[[modeliter]][-(1:2)], main = names(models)[modeliter])
}
save(models, file = paste('/Users/', user, '/Dropbox/Seo&Chang/Simulations.RData', sep = ''))
}})
new <- function(x) solve(crossprod(x))
new <- function(x) solve(crossprod(x))
profvis({
for (i in 1:1e1) {
x <- cbind(1, rnorm(50))
new(x)
}
})
new <- function(x) solve(crossprod(x))
profvis({
for (i in 1:1e1) {
x <- cbind(1, rnorm(50))
k <- new(x)
}
})
x <- mvnfast::rmvn(1e2, rep(0, 50), diag(1, 50))
new <- function(x) solve(crossprod(x))
profvis({
for (i in 1:1e1) {
x <- mvnfast::rmvn(1e2, rep(0, 50), diag(1, 50))
k <- new(x)
}
})
new <- function(x) solve(crossprod(x))
profvis({
for (i in 1:1e1) {
x <- mvnfast::rmvn(1e2, rep(0, 30), diag(1, 30))
k <- new(x)
}
})
